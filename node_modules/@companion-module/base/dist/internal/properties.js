"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertyManager = void 0;
const tslib_1 = require("tslib");
const debounce_fn_1 = tslib_1.__importDefault(require("debounce-fn"));
class PropertyManager {
    #updatePropertyValues;
    #setPropertyDefinitions;
    #log;
    #propertyDefinitions = new Map();
    // Property values waiting to be sent
    #pendingPropertyValues = new Map();
    // Properties currently being checked
    #propertiesBeingChecked = new Map();
    constructor(updatePropertyValues, setPropertyDefinitions, log) {
        this.#updatePropertyValues = updatePropertyValues;
        this.#setPropertyDefinitions = setPropertyDefinitions;
        this.#log = log;
    }
    async propertySet(msg) {
        const propertyDefinition = this.#propertyDefinitions.get(msg.property.propertyId);
        if (!propertyDefinition)
            throw new Error(`Unknown property: ${msg.property.propertyId}`);
        if (!propertyDefinition.setValue)
            throw new Error(`Property is readonly: ${msg.property.propertyId}`);
        // TODO - type safety?
        await propertyDefinition.setValue(msg.property.instanceId, msg.property.value, null);
    }
    #triggerCheckProperty(id) {
        const existingRecheck = this.#propertiesBeingChecked.get(id);
        if (existingRecheck) {
            // Already being checked
            existingRecheck.needsRecheck = true;
            return;
        }
        const propertyCheckStatus = {
            needsRecheck: false,
        };
        // mark it as being checked
        this.#propertiesBeingChecked.set(id, propertyCheckStatus);
        Promise.resolve()
            .then(async () => {
            const definition = this.#propertyDefinitions.get(id);
            let values = Promise.resolve(undefined);
            // Calculate the new value for the feedback
            if (definition && definition.getValues) {
                values = definition.getValues(null);
            }
            // Await the value before looking at this.#pendingFeedbackValues, to avoid race conditions
            const resolvedValues = await values;
            this.#pendingPropertyValues.set(id, {
                id: id,
                isSingleValue: !definition?.instanceIds,
                values: resolvedValues,
            });
            this.#sendPropertyValues();
        })
            .catch((e) => {
            console.error(`Property check failed: ${JSON.stringify({})} - ${e?.message ?? e} ${e?.stack}`);
        })
            .finally(() => {
            // it is no longer being checked
            this.#propertiesBeingChecked.delete(id);
            // If queued, trigger a check
            if (propertyCheckStatus.needsRecheck) {
                setImmediate(() => {
                    this.#triggerCheckProperty(id);
                });
            }
        });
    }
    /**
     * Send pending feedback values (from this.#pendingFeedbackValues) to companion, with a debounce
     */
    #sendPropertyValues = (0, debounce_fn_1.default)(() => {
        const newValues = this.#pendingPropertyValues;
        this.#pendingPropertyValues = new Map();
        // Send the new values back
        if (newValues.size > 0) {
            this.#updatePropertyValues({
                values: Array.from(newValues.values()),
            });
        }
    }, {
        wait: 5,
        maxWait: 25,
    });
    setPropertyDefinitions(properties) {
        const hostProperties = [];
        this.#propertyDefinitions.clear();
        const propertyIds = new Set();
        for (const [propertyId, property] of Object.entries(properties)) {
            if (property) {
                const newProperty = {
                    id: propertyId,
                    name: property.name,
                    description: property.description,
                    type: property.type,
                    instanceIds: property.instanceIds ?? null,
                    hasGetter: !!property.getValues,
                    hasSetter: !!property.setValue,
                    // type specific fields
                    // TODO - type these better
                    choices: property.choices,
                    allowCustom: property.allowCustom,
                    regex: property.regex,
                    min: property.min,
                    max: property.max,
                    step: property.step,
                    range: property.range,
                };
                hostProperties.push(newProperty);
                // Remember the definition locally
                this.#propertyDefinitions.set(propertyId, property);
                propertyIds.add(propertyId);
            }
        }
        this.#setPropertyDefinitions({ properties: hostProperties });
        for (const propertyId of propertyIds) {
            this.#triggerCheckProperty(propertyId);
        }
    }
    notifyPropertiesChanged(changes) {
        for (const id of Object.keys(changes)) {
            this.#triggerCheckProperty(id);
        }
    }
}
exports.PropertyManager = PropertyManager;
//# sourceMappingURL=properties.js.map